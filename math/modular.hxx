
namespace om636
{
	using om636::type_at;

    /////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	modular<T>::modular()
		: T()
	{}
		
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	modular<T>::modular(const modular & c)
		: T( c )
	{}
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	modular<T>::modular(const context_type & c) 
		: T( c )	
	{}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	modular<T>::~modular()
	{}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	modular<T> & modular<T>::operator=(modular c)
	{	
		swap(c);
		return *this;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void swap(modular<T> & lhs, modular<T> & rhs)
	{	lhs.swap( rhs );	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	template<class T, class U>
	T modular<C>::assign(const U & v)
	{	
		typedef typename type_at< typename T::value_type::list_type, 0 >::result_type::value_type num_type;
		return T( num_type( v ) % num_type(_mod) );
	} 
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	template<class T>
	void modular<C>::invert(const T & _m)
	{}
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	template<class T, class U>
	const T modular<C>::to_value(const U & _m)
	{
		typedef typename U::context_type::accessor_type accessor_type;
		accessor_type m( _m.value_ref() );
		return U::template to_value<T>( *(*m)[nat] );
	}

	/////////////////////////////////////////////////////////////////////////////////////////////
		
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	bool modular<C>::equal(const num_type & _n) const
	{
		const accessor_type m( value_ref() );
        accessor_type n( _n.value_ref() ); 
		return *(*m)[nat] == *(*n)[nat];
	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	int modular<C>::cmp(const num_type &) const
	{	
		ASSERT( false ); 
		return 0;	
	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	int modular<C>::sign() const 
	{	
		ASSERT( false ); 
		return 0;	
	}

	/////////////////////////////////////////////////////////////////////////////////////////////
  
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	void modular<C>::add(const num_type & _n)
	{
		accessor_type m( value_ref() );
		const accessor_type n( _n.value_ref() ); 
		*(*m)[nat] = (*(*m)[nat] + *(*n)[nat]) % value_type(_mod);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	template<class T>
	void modular<C>::subtract(const num_type & _n)
	{
		accessor_type m( value_ref() );
		const accessor_type n( _n.value_ref() ); 
		
		*(*m)[nat] = (*(*m)[nat] + (value_type(_mod) - *(*n)[nat])) % value_type(_mod);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	template<class T>
	void modular<C>::mult(const num_type & _n)
	{
		accessor_type m( value_ref() );
		const accessor_type n( _n.value_ref() );
	
		*(*m)[nat] = (*(*m)[nat] * *(*n)[nat]) % value_type(_mod); 
	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	void modular<C>::divide(const num_type & _n)
	{
		accessor_type m( value_ref() );
		const accessor_type n( _n.value_ref() );
	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	void modular<C>::remainder(const num_type & _n)
	{
		accessor_type m( value_ref() );
		const accessor_type n( _n.value_ref() );
	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T, class U>
	T & operator>>(T & s, number< modular< U > > & _m)
	{	
		typedef U::accessor_type accessor_type;
		accessor_type m( _m.value_ref() );
		return s >> *(*m)[nat];	
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T, class U>
	T & operator<<(T & s, number< modular< U > > & m)
	{	return s <<	m;	}

	/////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class C>
	template<class T>
	void modular<C>::power(T & _m, const T & _n)
	{
		typedef unsigned exp_type;
		typedef T::value_type value_type;
		
		exp_type e( T::to_value<exp_type>(_n) );	
		T result( _m );
		bool go( false );
		
		for(unsigned i(1 << sizeof(exp_type) * 8 - 1); i; i >>= 1)
		{
			if (!go)
				go = i & e; 
			else 
			{
				result *= result;	
				if (i & e)
					result *= _m;
			}
		}
		_m = result;
	}
}	// om636
