namespace om636
{
	using om636::type_at;
	using om636::index;
	using om636::singleton;
	using om636::create_new; 
	
	namespace
	{
		template<class> struct dummy_subject;
	
		template<class T>
		class polynomial_subject : public T
		{	
				
		public:			
			// types
			typedef T subject_type;
			
			typedef number< polynomial< subject_type > > num_type;
			typedef abstract_number< num_type > * value_type;
	
			// resources
			polynomial_subject();
			polynomial_subject(const polynomial_subject &);
			polynomial_subject(const subject_type &);
			~polynomial_subject();
			polynomial_subject & operator=(polynomial_subject); 
			void swap(polynomial_subject &); 
	
			// policy 
			void on_swap(const value_type &, const value_type &);
		private:
			//subject_type m_subject; 
		};
		
		template<class T>
		void swap(polynomial_subject<T> &, polynomial_subject<T> &); 
	}
	
	using om636::default_lifetime;
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	polynomial<T>::polynomial()
		: context_type( & singleton< dummy_subject<num_type>, om636::default_lifetime<dummy_subject<num_type> >, create_new<dummy_subject<num_type> > >::instance() )
	{}
		
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	polynomial<T>::polynomial(const polynomial & c)
		: context_type( dynamic_cast<const context_type &>(c) )
	{}	
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	polynomial<T>::polynomial(const value_type & c) 
		: context_type(& singleton< dummy_subject<num_type>, toolbag::default_lifetime<dummy_subject<num_type> >, create_new<dummy_subject<num_type> > >::instance(), c)
	{}	
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	polynomial<T>::~polynomial()
	{}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void polynomial<T>::swap(polynomial & a)
	{	context_type::swap(a);	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	polynomial<T> & polynomial<T>::operator=(polynomial a)
	{	
		swap(a);	
		return *this;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	typename polynomial<T>::impl_type * polynomial<T>::evaluate() const 
	{	return const_cast< polynomial<T> & >(*this).evaluate();	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	typename polynomial<T>::impl_type * polynomial<T>::evaluate()
	{	return context_type::value_ref();	}
		
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T> 
	template<class U>
	const U & polynomial<T>::identity()
	{
		static U local(0);
		return local;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	template<class U>
	void polynomial<T>::invert(U & v)
	{
		using std::swap;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	template<class U, class V>
	U polynomial<T>::assign(const V & v)
	{	
		return U(); 
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	template<class U, class V>
	U polynomial<T>::to_value(const V & _m)
	{
		U result;
		return result;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	bool polynomial<T>::equal(const num_type & lhs, const num_type & rhs) const
	{	return value_ref()->equal(lhs, rhs);	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	int polynomial<T>::sign(const num_type & lhs, const num_type & rhs) const
	{	return value_ref()->sign(lhs, rhs); }
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	int polynomial<T>::sign(const num_type & n) const 
	{	return value_ref()->sign(n); }
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void polynomial<T>::add(num_type & lhs, const num_type & rhs) const
	{	value_ref()->add(lhs, rhs); }
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void polynomial<T>::subtract(num_type & lhs, const num_type & rhs) const
	{ 	value_ref()->subtract(lhs, rhs); 	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void polynomial<T>::mult(num_type & lhs, const num_type & rhs) const
	{ 	value_ref()->mult(lhs, rhs); }
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void polynomial<T>::divide(num_type & lhs, const num_type & rhs) const
	{	value_ref()->divide(lhs, rhs);	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	void polynomial<T>::remainder(num_type & lhs, const num_type & rhs) const
	{	value_ref()->remainder(lhs, rhs); }
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T>
	template<class U>
	void polynomial<T>::power(U &, const U &)
	{}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T, class U>
	void swap(polynomial< U > & lhs, polynomial< U > &)
	{	lhs.swap( rhs ); 	}	
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T, class U>
	T & operator>>(T & s, number< polynomial< U > > &)
	{ 	return s;	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	template<class T, class U>
	T & operator<<(T & s, const number< polynomial< U > > &)
	{ 	return s; 	} 
	
	namespace // private
	{
		template<class T>
		struct dummy_subject : public abstract_number< T >
		{
			// types 
			typedef abstract_number<T> base_type;
			typedef base_type::value_type value_type; 
			
			// comparisons
			bool equal(const value_type & lhs, const value_type & rhs) const 
			{ 	return lhs.evaluate()->equal(lhs, rhs); }
			
			int sign(const value_type & lhs, const value_type & rhs) const
			{ 	return lhs.evaluate()->sign(lhs, rhs);	}
			
			int sign(const value_type & n) const
			{ 	return n.evaluate()->sign(n); }
				
			// modifiers
			void add(value_type & lhs, const value_type & rhs) const
			{
				typedef value_type::subject_type subject_type;
				typedef subject_type::const_iterator const_iterator; 
				typedef subject_type::iterator iterator; 
				
				for (const_iterator i(rhs.subject_ref().begin()), e( rhs.subject_ref().end() ); i != e; i++)
					lhs.subject_ref()[(*i).first] += (*i).second;
				//lhs.subject_ref();
			}
					
			void subtract(value_type &, const value_type &) const
			{}
			
			void mult(value_type & lhs, const value_type & rhs) const
			{ 	lhs.evaluate()->mult(lhs, rhs); }
			
			void divide(value_type & lhs, const value_type & rhs) const
			{ 	lhs.evaluate()->divide(lhs, rhs); }
			
			void remainder(value_type & lhs, const value_type & rhs) const
			{ 	lhs.evaluate()->remainder(lhs, rhs); }
		}; 
		
		// subject
	
		/////////////////////////////////////////////////////////////////////////////////////////////
	
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		polynomial_subject<T>::polynomial_subject() 
		//	: T() 
		{}
	
		/////////////////////////////////////////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		polynomial_subject<T>::polynomial_subject(const polynomial_subject &) 
			//: T( dynamic_cast< const subject_type & >(c) ) 
		{}
			
		/////////////////////////////////////////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		polynomial_subject<T>::polynomial_subject(const subject_type &) 
		//	: T(c) 
		{} 
			
		/////////////////////////////////////////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		polynomial_subject<T>::~polynomial_subject() 
		{}
	
		/////////////////////////////////////////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		polynomial_subject<T> & polynomial_subject<T>::operator=(polynomial_subject c) 
		{	
			swap(c); 
			return *this; 
		}
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		void polynomial_subject<T>::swap(polynomial_subject &) 
		{ 	}//T::swap(c); } 
	
		/////////////////////////////////////////////////////////////////////////////////////////////
	
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		void swap(polynomial_subject<T> & lhs, polynomial_subject<T> & rhs)
		{	lhs.swap( rhs );	}
	
		/////////////////////////////////////////////////////////////////////////////////////////////
	
		/////////////////////////////////////////////////////////////////////////////////////////////
		template<class T>
		void polynomial_subject<T>::on_swap(const value_type &, const value_type &)
		{}
	} 	// namespace
}   // om636
